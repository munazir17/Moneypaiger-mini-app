<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

<script>
const contractAddress = "0x995d1e3471c06f27ad145cc7d0d0bb48f38ad938";
const abi = [
  "function publicMint() external",
  "function currentTokenId() public view returns (uint256)",
  "function maxSupply() public view returns (uint256)",
  "function publicMintActive() public view returns (bool)"
];

let provider, signer, contract;
let userAddress = null;

// Update supply counter using currentTokenId
async function updateSupply() {
  try {
    let total = 0;
    let max = 1000000; // hardcoded max supply since contract has maxSupply
    if(contract) {
      total = await contract.currentTokenId();
    }
    document.getElementById('supply-counter').textContent = `Minted: ${total.toString()} / ${max.toString()}`;
  } catch (error) {
    console.error('Supply fetch error:', error);
    document.getElementById('supply-counter').textContent = 'Supply: Check wallet connection';
  }
}

async function connectWallet() {
  const btn = document.getElementById('connectBtn');
  const walletEl = document.getElementById('connected-wallet');
  
  if (!window.ethereum) { alert('Please install MetaMask!'); return; }

  try {
    btn.textContent = 'Connecting...';
    btn.disabled = true;

    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    userAddress = accounts[0];

    provider = new ethers.providers.Web3Provider(window.ethereum);
    signer = provider.getSigner();
    contract = new ethers.Contract(contractAddress, abi, signer);

    btn.textContent = 'Connected';
    walletEl.textContent = `Wallet: ${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;

    await updateSupply();

  } catch (error) {
    console.error('Connection error:', error);
    btn.textContent = 'Connect Wallet';
    btn.disabled = false;
    walletEl.textContent = '';
    alert('Failed to connect wallet: ' + error.message);
  }
}

async function mintNFT(amount, statusId) {
  const statusEl = document.getElementById(statusId);
  const btn = statusEl.previousElementSibling;

  if(!contract || !signer){
    statusEl.className='status error';
    statusEl.textContent='Please connect your wallet first!';
    return;
  }

  try {
    btn.disabled = true;
    btn.textContent='Minting...';
    statusEl.className='status info';
    statusEl.textContent='Confirm transaction in your wallet...';

    const tx = await contract.publicMint(); // free mint
    statusEl.textContent='Transaction submitted! Waiting confirmation...';
    await tx.wait();

    statusEl.className='status success';
    statusEl.textContent='âœ… NFT Minted Successfully!';
    await updateSupply();

    setTimeout(()=>{btn.disabled=false; btn.textContent='Mint NFT';},3000);
  } catch(error) {
    console.error('Mint error:', error);
    statusEl.className='status error';
    if(error.code===4001) statusEl.textContent='Transaction rejected by user';
    else statusEl.textContent='Mint failed: '+(error.reason||error.message);
    btn.disabled=false; btn.textContent='Mint NFT';
  }
}

document.getElementById('connectBtn').addEventListener('click', connectWallet);
window.addEventListener('load', async()=>{
  if(window.ethereum){
    try{
      const accounts = await window.ethereum.request({ method:'eth_accounts' });
      if(accounts.length>0) await connectWallet();
      else await updateSupply();
    }catch(err){ console.error(err); await updateSupply(); }
  } else { await updateSupply(); }
});
</script>

<script>
// Base network details
const baseNetwork = {
  chainId: '0x2105', // 8453 in hex
  chainName: 'Base Mainnet',
  nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
  rpcUrls: ['https://mainnet.base.org'],
  blockExplorerUrls: ['https://basescan.org']
};

// Function to check network
async function checkNetwork() {
  if (!window.ethereum) return false;
  const currentChain = await window.ethereum.request({ method: 'eth_chainId' });
  if (currentChain !== baseNetwork.chainId) {
    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: baseNetwork.chainId }],
      });
      return true;
    } catch (switchError) {
      // If network not added, request to add it
      if (switchError.code === 4902) {
        try {
          await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [baseNetwork],
          });
          return true;
        } catch (addError) {
          alert('Please add Base network in MetaMask!');
          return false;
        }
      } else {
        alert('Please switch to Base network!');
        return false;
      }
    }
  }
  return true; // Already on Base
}

// Connect wallet button with network check
connectBtn.onclick = async () => {
  if (!window.ethereum) { alert("Install MetaMask!"); return; }
  const networkOk = await checkNetwork();
  if (!networkOk) return;
  try {
    await window.ethereum.request({ method:'eth_requestAccounts' });
    provider = new ethers.BrowserProvider(window.ethereum);
    signer = await provider.getSigner();
    contract = new ethers.Contract(contractAddress, abi, signer);
    connectBtn.innerText = "Wallet Connected ✅";
    connectBtn.disabled = true;
  } catch(err) { console.error(err); alert("Wallet connection failed: "+err.message); }
};

// Mint function now checks network first
async function mintNFT(amount=1,statusId){
  const statusEl = document.getElementById(statusId);
  if(!window.ethereum){ alert("Install MetaMask!"); return; }
  const networkOk = await checkNetwork();
  if(!networkOk) return;

  if(!provider){
    try{
      await window.ethereum.request({method:'eth_requestAccounts'});
      provider = new ethers.BrowserProvider(window.ethereum);
      signer = await provider.getSigner();
      contract = new ethers.Contract(contractAddress, abi, signer);
      connectBtn.innerText = "Wallet Connected ✅";
      connectBtn.disabled = true;
    } catch(err){ console.error(err); alert("Wallet connection failed: "+err.message); return; }
  }

  try{
    statusEl.className="status";
    statusEl.innerText="Minting... please wait!";
    const tx = await contract.mint(amount,{value:0});
    await tx.wait();
    statusEl.className="status success";
    statusEl.innerText=`Successfully minted ${amount} NFT(s)!`;
    updateSupply();
  } catch(err){
    console.error(err);
    statusEl.className="status error";
    statusEl.innerText="Mint failed: "+(err?.data?.message||err.message||"Unknown error");
  }
}
</script>
